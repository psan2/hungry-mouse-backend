class Match < ApplicationRecord
    belongs_to :player
    belongs_to :game
    has_many :foods
    has_many :bites
    has_many :food_grids, through: :foods

    def other_matches( this_match=self )
        this_match.game.matches.select {|match|match.id!=this_match.id}.each {|current_match| }
    end

    def other_ai( this_match=self, current_round )
        other_matches(this_match).select {|match| match.player.ai==true && match.round_no<current_round}
    end

    def winner?( this_match=self )
        if other_matches(this_match).select{ |match| match.loser==false }.length==0
            this_match.winner=true;
            this_match.save;
        end
        this_match.winner
    end

    def bite(x_pos=0, y_pos=0 )
        # Nibble for self, then see if there is any AI to be done
        nibble_hash = {
            this_shot:{},
            ai_shots:[]
        }

        nibble_hash[:this_shot] = nibble(self, x_pos, y_pos)
# After having a nibble, check if the next player in the sequence is a computer,
# if so, run their game, not passing in positions, so they are computer generated
# GET ALL WITH ROUND_NO LESS THAN CURRENT ONE AND NIBBLE AWAY IF THEY ARE COMPUTERS
        other_ai( self, self.round_no ).each {|match|
            nibble_hash[:ai_shots] << nibble(match)
        } 

# Return the hash of the shot, and all others generated by a computer
        nibble_hash
    end

    def nibble(this_match, x_pos=0, y_pos=0)
# Run this for a player to take a nibble
# When a nibble is taken it can nibble or miss, 
# if nibble, it can eat the food fully or not
# if eaten the food, it could win the game
# After having a nibble, check if the next player in the sequence is a computer,
# if so, run their game, not passing in positions, so they are computer generated

# TODO Generate x and y if 0 for the AI ..... need to turn into a function and be smart
        if x_pos==0 || y_pos==0
            shot=suggested_shots(this_match).sample
            x_pos=shot[:x]
            y_pos=shot[:y]
        end 

        nibble_hash = { player_id:this_match.player.id, 
                    player:this_match.player.name,
                    round_no:this_match.round_no,
                    x_pos:x_pos,
                    y_pos:y_pos,
                    nibbled:false,
                    eaten:false,
                    won:false
                     } # Will be used to show what has happened

# Create the bite record
    thisbite = Bite.create(match_id:this_match.id, x_pos:x_pos, y_pos:y_pos, bite:false)

    other_matches(this_match).each { |other_match|   
        other_match.foods.each { |other_food|
            FoodGrid.where(["food_id=? and x_pos=? and y_pos=?", other_food.id,x_pos, y_pos]).each {|other_foodgrid|
                other_foodgrid.bite=true
                nibble_hash[:nibbled]=true
                other_foodgrid.save
                thisbite.bite=true;
                thisbite.save;
        # If no other bits to bite, then set the food item to eaten
            food_to_eat=FoodGrid.where(["food_id=? and bite = false ", other_foodgrid.food_id])
            if food_to_eat.length==0 
               other_foodgrid.food.eaten=true
               nibble_hash[:eaten]=true
               other_foodgrid.food.save

             # So if the food is eaten, see if there are any other uneaten foods for any other players in the game
                 if other_match.food_grids.select {|f| f.bite==false }.length==0
                # This match is a loser ..... we can't say we are a winner just yet, as there may be more than 2 players
                     other_match.loser=true;
                     other_match.save
                     # As we have set a player to being a loser, now is a good time to see if we are a winner
                     nibble_hash[:won] = winner?( this_match )
                 end # End the setting this player a loser stuff
 
            end # End the setting the food element to eaten
            } # End the other food_grid loop
          } # End the other_food loop
        } # End the other_match loop    

        # Set the round number
        this_match.round_no+=1
        this_match.save

        # Return the hash
        nibble_hash
    end

    def successfullbites(this_match=self)
        # Get all of the bites, linked to foods that are not eaten
        # WORKTODO HERE ... NEED TO LIMIT TO UNEATEN FOODS
        this_match.bites.select {|b| b.bite==true } # Get the last bite
    end

    def suggested_shots(this_match=self) 
# Build an array of good shots, that can be sampled .... in theory this could be used 
# as a help feature/function
# 1) If the last bite, nibbled some cheese that isn't eaten surround that area
# 2) Based upon the smallest cheese that still exists for other players, 
#    build an array that covers the area best for horizontal and vertical placement
#   return this for sampling

        return_array=[]
        last_bite=successfullbites(this_match).last # Get the last bite

puts(last_bite)

        if last_bite # Just in case this is the 1st bite
            search_x=last_bite.x_pos
            search_y=last_bite.y_pos    
    # Get all of the foods nibbled by the last bite, that we will loop over to build an array of potential shots
            other_matches(this_match).each {|other_match|
                other_match.food_grids.where(["food_grids.x_pos=? and food_grids.y_pos=?",search_x, search_y]).each {|nibbled_food|
                  if !nibbled_food.food.eaten # If not fully eaten
# Superb!!! lets build a sample around this cell
# if we assume this hit was 3.3, then good places are 2.3, 4.3, 3.2 or 3.4
# if one of those was a hit, for this food, then we know the orientation, so only 2 choices
# but surrounding the sequence of hits.
                    search_array=[ {x:search_x-1, y:search_y, horizontal:true, x_shift:-1, y_shift:0 },
                        {x:search_x+1, y:search_y, horizontal:true,  x_shift:+1, y_shift:0 },
                        {x:search_x, y:search_y-1, horizontal:false,  x_shift:0, y_shift:-1 },
                        {x:search_x, y:search_y+1, horizontal:false,  x_shift:0, y_shift:+1 }]

                    search_array.each {|search| # Loop thru each array element
                    # Check if the element has been modified or valid, and if not dont do the rest
                        if search[:x]==0 || search[:y]==0
                            continue_search=false;
                        else
                            continue_search=true;
                        end

                        while( continue_search )
                                if this_match.bites.where(["x_pos=? and y_pos=?",search[:x], search[:y]]).length>0
                                    # We did bite here .... so see if this was a hit.
                                    if FoodGrid.where(["food_id= ? and x_pos=? and y_pos=?",nibbled_food.food_id, search[:x], search[:y]]).length>0
                                    # And that bite, was a nibble ... so we need to perform a shift and continue the loop
                                        search[:x]+=search[:x_shift]
                                        search[:y]+=search[:y_shift]
                                        if search[:horizontal]
                                            search_array[2][:x]=0 # Make the vertical ones irrelevant
                                            search_array[3][:x]=0
                                        else
                                            search_array[0][:x]=0 # Make the horizontal ones irrelevant
                                            search_array[1][:x]=0
                                        end                            
                                    else # End of we did nibble here, but it wasn't a bite, so end of the road for this search option
                                        continue_search=false;
                                        search[:x]=0;
                                    end
                                else 
                                    # we haven't bitten here, so keep the array intact, but exit the loop
                                    continue_search=false;
                                end  # End of we did bite here
                        end # End the while loop

                      } # End of search array loop

        # Ok, so we have done some amazing stuff to get best shots if you are close to eating some food
        # now, we want to build the return hash with all of the none x elements
                    search_array.each {|search|
                        if search[:x]!=0 && search[:y]!=0
                            return_array << search
                        end
                    }
                end # End of check if there is some more to nibble
                    } # End nibbled food loop
            } # End of other match loop
        end # End of the .. has there been a previous bite check

# At the end of all of that, if there are no choices on the return_array
# randomly generate a valid option
# TODO Generate x and y if 0 for the AI ..... need to turn into a function and be smart
#        x_pos = rand(1..this_match.game.qty_columns)
#        y_pos = rand(1..this_match.game.qty_rows)
# rather than randomly generate, then try and get a position ... build an array of possibilities
        if return_array.length==0
            search_x=0
            search_y=0
            self.game.qty_columns.times do
                search_x+=1
                self.game.qty_rows.times do
                    search_y+= 1
                    if this_match.bites.where(["x_pos=? and y_pos=?",search_x, search_y]).length==0   
                        return_array << {x:search_x,y:search_y}
                    end
                end
                search_y=0;
            end # End of array building do
        end

        return_array

    end

end